// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: corpus.proto

#ifndef PROTOBUF_corpus_2eproto__INCLUDED
#define PROTOBUF_corpus_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace NLPCommon {
namespace CorpusProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_corpus_2eproto();
void protobuf_AssignDesc_corpus_2eproto();
void protobuf_ShutdownFile_corpus_2eproto();

class Token;
class Interpretation;
class Tagset;
class Tagset_Category;
class Tagset_PartOfSpeech;

enum Token_Type {
  Token_Type_SEGMENT = 0,
  Token_Type_NO_SPACE = 1,
  Token_Type_START_OF_SENTENCE = 2,
  Token_Type_END_OF_SENTENCE = 3,
  Token_Type_START_OF_PARAGRAPH = 4,
  Token_Type_END_OF_PARAGRAPH = 5
};
bool Token_Type_IsValid(int value);
const Token_Type Token_Type_Type_MIN = Token_Type_SEGMENT;
const Token_Type Token_Type_Type_MAX = Token_Type_END_OF_PARAGRAPH;
const int Token_Type_Type_ARRAYSIZE = Token_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Token_Type_descriptor();
inline const ::std::string& Token_Type_Name(Token_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Token_Type_descriptor(), value);
}
inline bool Token_Type_Parse(
    const ::std::string& name, Token_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Token_Type>(
    Token_Type_descriptor(), name, value);
}
// ===================================================================

class Token : public ::google::protobuf::Message {
 public:
  Token();
  virtual ~Token();
  
  Token(const Token& from);
  
  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Token& default_instance();
  
  void Swap(Token* other);
  
  // implements Message ----------------------------------------------
  
  Token* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Token_Type Type;
  static const Type SEGMENT = Token_Type_SEGMENT;
  static const Type NO_SPACE = Token_Type_NO_SPACE;
  static const Type START_OF_SENTENCE = Token_Type_START_OF_SENTENCE;
  static const Type END_OF_SENTENCE = Token_Type_END_OF_SENTENCE;
  static const Type START_OF_PARAGRAPH = Token_Type_START_OF_PARAGRAPH;
  static const Type END_OF_PARAGRAPH = Token_Type_END_OF_PARAGRAPH;
  static inline bool Type_IsValid(int value) {
    return Token_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Token_Type_Type_MIN;
  static const Type Type_MAX =
    Token_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Token_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Token_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Token_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Token_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .NLPCommon.CorpusProto.Token.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NLPCommon::CorpusProto::Token_Type type() const;
  inline void set_type(::NLPCommon::CorpusProto::Token_Type value);
  
  // optional string orth = 2;
  inline bool has_orth() const;
  inline void clear_orth();
  static const int kOrthFieldNumber = 2;
  inline const ::std::string& orth() const;
  inline void set_orth(const ::std::string& value);
  inline void set_orth(const char* value);
  inline void set_orth(const char* value, size_t size);
  inline ::std::string* mutable_orth();
  
  // repeated .NLPCommon.CorpusProto.Interpretation interp = 3;
  inline int interp_size() const;
  inline void clear_interp();
  static const int kInterpFieldNumber = 3;
  inline const ::NLPCommon::CorpusProto::Interpretation& interp(int index) const;
  inline ::NLPCommon::CorpusProto::Interpretation* mutable_interp(int index);
  inline ::NLPCommon::CorpusProto::Interpretation* add_interp();
  inline const ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Interpretation >&
      interp() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Interpretation >*
      mutable_interp();
  
  // @@protoc_insertion_point(class_scope:NLPCommon.CorpusProto.Token)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::std::string* orth_;
  static const ::std::string _default_orth_;
  ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Interpretation > interp_;
  friend void  protobuf_AddDesc_corpus_2eproto();
  friend void protobuf_AssignDesc_corpus_2eproto();
  friend void protobuf_ShutdownFile_corpus_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Token* default_instance_;
};
// -------------------------------------------------------------------

class Interpretation : public ::google::protobuf::Message {
 public:
  Interpretation();
  virtual ~Interpretation();
  
  Interpretation(const Interpretation& from);
  
  inline Interpretation& operator=(const Interpretation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Interpretation& default_instance();
  
  void Swap(Interpretation* other);
  
  // implements Message ----------------------------------------------
  
  Interpretation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Interpretation& from);
  void MergeFrom(const Interpretation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // optional string base = 2;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 2;
  inline const ::std::string& base() const;
  inline void set_base(const ::std::string& value);
  inline void set_base(const char* value);
  inline void set_base(const char* value, size_t size);
  inline ::std::string* mutable_base();
  
  // optional bool is_golden = 3 [default = false];
  inline bool has_is_golden() const;
  inline void clear_is_golden();
  static const int kIsGoldenFieldNumber = 3;
  inline bool is_golden() const;
  inline void set_is_golden(bool value);
  
  // optional bool is_autoselected = 4 [default = false];
  inline bool has_is_autoselected() const;
  inline void clear_is_autoselected();
  static const int kIsAutoselectedFieldNumber = 4;
  inline bool is_autoselected() const;
  inline void set_is_autoselected(bool value);
  
  // @@protoc_insertion_point(class_scope:NLPCommon.CorpusProto.Interpretation)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  ::std::string* base_;
  static const ::std::string _default_base_;
  bool is_golden_;
  bool is_autoselected_;
  friend void  protobuf_AddDesc_corpus_2eproto();
  friend void protobuf_AssignDesc_corpus_2eproto();
  friend void protobuf_ShutdownFile_corpus_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Interpretation* default_instance_;
};
// -------------------------------------------------------------------

class Tagset_Category : public ::google::protobuf::Message {
 public:
  Tagset_Category();
  virtual ~Tagset_Category();
  
  Tagset_Category(const Tagset_Category& from);
  
  inline Tagset_Category& operator=(const Tagset_Category& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tagset_Category& default_instance();
  
  void Swap(Tagset_Category* other);
  
  // implements Message ----------------------------------------------
  
  Tagset_Category* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tagset_Category& from);
  void MergeFrom(const Tagset_Category& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated string values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();
  
  // @@protoc_insertion_point(class_scope:NLPCommon.CorpusProto.Tagset.Category)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  friend void  protobuf_AddDesc_corpus_2eproto();
  friend void protobuf_AssignDesc_corpus_2eproto();
  friend void protobuf_ShutdownFile_corpus_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Tagset_Category* default_instance_;
};
// -------------------------------------------------------------------

class Tagset_PartOfSpeech : public ::google::protobuf::Message {
 public:
  Tagset_PartOfSpeech();
  virtual ~Tagset_PartOfSpeech();
  
  Tagset_PartOfSpeech(const Tagset_PartOfSpeech& from);
  
  inline Tagset_PartOfSpeech& operator=(const Tagset_PartOfSpeech& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tagset_PartOfSpeech& default_instance();
  
  void Swap(Tagset_PartOfSpeech* other);
  
  // implements Message ----------------------------------------------
  
  Tagset_PartOfSpeech* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tagset_PartOfSpeech& from);
  void MergeFrom(const Tagset_PartOfSpeech& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated string categories = 2;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 2;
  inline const ::std::string& categories(int index) const;
  inline ::std::string* mutable_categories(int index);
  inline void set_categories(int index, const ::std::string& value);
  inline void set_categories(int index, const char* value);
  inline void set_categories(int index, const char* value, size_t size);
  inline ::std::string* add_categories();
  inline void add_categories(const ::std::string& value);
  inline void add_categories(const char* value);
  inline void add_categories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& categories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_categories();
  
  // repeated bool required_categories_mask = 3;
  inline int required_categories_mask_size() const;
  inline void clear_required_categories_mask();
  static const int kRequiredCategoriesMaskFieldNumber = 3;
  inline bool required_categories_mask(int index) const;
  inline void set_required_categories_mask(int index, bool value);
  inline void add_required_categories_mask(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      required_categories_mask() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_required_categories_mask();
  
  // @@protoc_insertion_point(class_scope:NLPCommon.CorpusProto.Tagset.PartOfSpeech)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> categories_;
  ::google::protobuf::RepeatedField< bool > required_categories_mask_;
  friend void  protobuf_AddDesc_corpus_2eproto();
  friend void protobuf_AssignDesc_corpus_2eproto();
  friend void protobuf_ShutdownFile_corpus_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Tagset_PartOfSpeech* default_instance_;
};
// -------------------------------------------------------------------

class Tagset : public ::google::protobuf::Message {
 public:
  Tagset();
  virtual ~Tagset();
  
  Tagset(const Tagset& from);
  
  inline Tagset& operator=(const Tagset& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tagset& default_instance();
  
  void Swap(Tagset* other);
  
  // implements Message ----------------------------------------------
  
  Tagset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tagset& from);
  void MergeFrom(const Tagset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Tagset_Category Category;
  typedef Tagset_PartOfSpeech PartOfSpeech;
  
  // accessors -------------------------------------------------------
  
  // repeated .NLPCommon.CorpusProto.Tagset.Category categories = 1;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 1;
  inline const ::NLPCommon::CorpusProto::Tagset_Category& categories(int index) const;
  inline ::NLPCommon::CorpusProto::Tagset_Category* mutable_categories(int index);
  inline ::NLPCommon::CorpusProto::Tagset_Category* add_categories();
  inline const ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_Category >&
      categories() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_Category >*
      mutable_categories();
  
  // repeated .NLPCommon.CorpusProto.Tagset.PartOfSpeech pos = 2;
  inline int pos_size() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline const ::NLPCommon::CorpusProto::Tagset_PartOfSpeech& pos(int index) const;
  inline ::NLPCommon::CorpusProto::Tagset_PartOfSpeech* mutable_pos(int index);
  inline ::NLPCommon::CorpusProto::Tagset_PartOfSpeech* add_pos();
  inline const ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_PartOfSpeech >&
      pos() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_PartOfSpeech >*
      mutable_pos();
  
  // @@protoc_insertion_point(class_scope:NLPCommon.CorpusProto.Tagset)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_Category > categories_;
  ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_PartOfSpeech > pos_;
  friend void  protobuf_AddDesc_corpus_2eproto();
  friend void protobuf_AssignDesc_corpus_2eproto();
  friend void protobuf_ShutdownFile_corpus_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Tagset* default_instance_;
};
// ===================================================================


// ===================================================================

// Token

// required .NLPCommon.CorpusProto.Token.Type type = 1;
inline bool Token::has_type() const {
  return _has_bit(0);
}
inline void Token::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::NLPCommon::CorpusProto::Token_Type Token::type() const {
  return static_cast< ::NLPCommon::CorpusProto::Token_Type >(type_);
}
inline void Token::set_type(::NLPCommon::CorpusProto::Token_Type value) {
  GOOGLE_DCHECK(::NLPCommon::CorpusProto::Token_Type_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional string orth = 2;
inline bool Token::has_orth() const {
  return _has_bit(1);
}
inline void Token::clear_orth() {
  if (orth_ != &_default_orth_) {
    orth_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Token::orth() const {
  return *orth_;
}
inline void Token::set_orth(const ::std::string& value) {
  _set_bit(1);
  if (orth_ == &_default_orth_) {
    orth_ = new ::std::string;
  }
  orth_->assign(value);
}
inline void Token::set_orth(const char* value) {
  _set_bit(1);
  if (orth_ == &_default_orth_) {
    orth_ = new ::std::string;
  }
  orth_->assign(value);
}
inline void Token::set_orth(const char* value, size_t size) {
  _set_bit(1);
  if (orth_ == &_default_orth_) {
    orth_ = new ::std::string;
  }
  orth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_orth() {
  _set_bit(1);
  if (orth_ == &_default_orth_) {
    orth_ = new ::std::string;
  }
  return orth_;
}

// repeated .NLPCommon.CorpusProto.Interpretation interp = 3;
inline int Token::interp_size() const {
  return interp_.size();
}
inline void Token::clear_interp() {
  interp_.Clear();
}
inline const ::NLPCommon::CorpusProto::Interpretation& Token::interp(int index) const {
  return interp_.Get(index);
}
inline ::NLPCommon::CorpusProto::Interpretation* Token::mutable_interp(int index) {
  return interp_.Mutable(index);
}
inline ::NLPCommon::CorpusProto::Interpretation* Token::add_interp() {
  return interp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Interpretation >&
Token::interp() const {
  return interp_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Interpretation >*
Token::mutable_interp() {
  return &interp_;
}

// -------------------------------------------------------------------

// Interpretation

// required string tag = 1;
inline bool Interpretation::has_tag() const {
  return _has_bit(0);
}
inline void Interpretation::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Interpretation::tag() const {
  return *tag_;
}
inline void Interpretation::set_tag(const ::std::string& value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Interpretation::set_tag(const char* value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Interpretation::set_tag(const char* value, size_t size) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Interpretation::mutable_tag() {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// optional string base = 2;
inline bool Interpretation::has_base() const {
  return _has_bit(1);
}
inline void Interpretation::clear_base() {
  if (base_ != &_default_base_) {
    base_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Interpretation::base() const {
  return *base_;
}
inline void Interpretation::set_base(const ::std::string& value) {
  _set_bit(1);
  if (base_ == &_default_base_) {
    base_ = new ::std::string;
  }
  base_->assign(value);
}
inline void Interpretation::set_base(const char* value) {
  _set_bit(1);
  if (base_ == &_default_base_) {
    base_ = new ::std::string;
  }
  base_->assign(value);
}
inline void Interpretation::set_base(const char* value, size_t size) {
  _set_bit(1);
  if (base_ == &_default_base_) {
    base_ = new ::std::string;
  }
  base_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Interpretation::mutable_base() {
  _set_bit(1);
  if (base_ == &_default_base_) {
    base_ = new ::std::string;
  }
  return base_;
}

// optional bool is_golden = 3 [default = false];
inline bool Interpretation::has_is_golden() const {
  return _has_bit(2);
}
inline void Interpretation::clear_is_golden() {
  is_golden_ = false;
  _clear_bit(2);
}
inline bool Interpretation::is_golden() const {
  return is_golden_;
}
inline void Interpretation::set_is_golden(bool value) {
  _set_bit(2);
  is_golden_ = value;
}

// optional bool is_autoselected = 4 [default = false];
inline bool Interpretation::has_is_autoselected() const {
  return _has_bit(3);
}
inline void Interpretation::clear_is_autoselected() {
  is_autoselected_ = false;
  _clear_bit(3);
}
inline bool Interpretation::is_autoselected() const {
  return is_autoselected_;
}
inline void Interpretation::set_is_autoselected(bool value) {
  _set_bit(3);
  is_autoselected_ = value;
}

// -------------------------------------------------------------------

// Tagset_Category

// required string name = 1;
inline bool Tagset_Category::has_name() const {
  return _has_bit(0);
}
inline void Tagset_Category::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Tagset_Category::name() const {
  return *name_;
}
inline void Tagset_Category::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Tagset_Category::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Tagset_Category::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tagset_Category::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated string values = 2;
inline int Tagset_Category::values_size() const {
  return values_.size();
}
inline void Tagset_Category::clear_values() {
  values_.Clear();
}
inline const ::std::string& Tagset_Category::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* Tagset_Category::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void Tagset_Category::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void Tagset_Category::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void Tagset_Category::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tagset_Category::add_values() {
  return values_.Add();
}
inline void Tagset_Category::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void Tagset_Category::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void Tagset_Category::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Tagset_Category::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Tagset_Category::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// Tagset_PartOfSpeech

// required string name = 1;
inline bool Tagset_PartOfSpeech::has_name() const {
  return _has_bit(0);
}
inline void Tagset_PartOfSpeech::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Tagset_PartOfSpeech::name() const {
  return *name_;
}
inline void Tagset_PartOfSpeech::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Tagset_PartOfSpeech::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Tagset_PartOfSpeech::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tagset_PartOfSpeech::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated string categories = 2;
inline int Tagset_PartOfSpeech::categories_size() const {
  return categories_.size();
}
inline void Tagset_PartOfSpeech::clear_categories() {
  categories_.Clear();
}
inline const ::std::string& Tagset_PartOfSpeech::categories(int index) const {
  return categories_.Get(index);
}
inline ::std::string* Tagset_PartOfSpeech::mutable_categories(int index) {
  return categories_.Mutable(index);
}
inline void Tagset_PartOfSpeech::set_categories(int index, const ::std::string& value) {
  categories_.Mutable(index)->assign(value);
}
inline void Tagset_PartOfSpeech::set_categories(int index, const char* value) {
  categories_.Mutable(index)->assign(value);
}
inline void Tagset_PartOfSpeech::set_categories(int index, const char* value, size_t size) {
  categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tagset_PartOfSpeech::add_categories() {
  return categories_.Add();
}
inline void Tagset_PartOfSpeech::add_categories(const ::std::string& value) {
  categories_.Add()->assign(value);
}
inline void Tagset_PartOfSpeech::add_categories(const char* value) {
  categories_.Add()->assign(value);
}
inline void Tagset_PartOfSpeech::add_categories(const char* value, size_t size) {
  categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Tagset_PartOfSpeech::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Tagset_PartOfSpeech::mutable_categories() {
  return &categories_;
}

// repeated bool required_categories_mask = 3;
inline int Tagset_PartOfSpeech::required_categories_mask_size() const {
  return required_categories_mask_.size();
}
inline void Tagset_PartOfSpeech::clear_required_categories_mask() {
  required_categories_mask_.Clear();
}
inline bool Tagset_PartOfSpeech::required_categories_mask(int index) const {
  return required_categories_mask_.Get(index);
}
inline void Tagset_PartOfSpeech::set_required_categories_mask(int index, bool value) {
  required_categories_mask_.Set(index, value);
}
inline void Tagset_PartOfSpeech::add_required_categories_mask(bool value) {
  required_categories_mask_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
Tagset_PartOfSpeech::required_categories_mask() const {
  return required_categories_mask_;
}
inline ::google::protobuf::RepeatedField< bool >*
Tagset_PartOfSpeech::mutable_required_categories_mask() {
  return &required_categories_mask_;
}

// -------------------------------------------------------------------

// Tagset

// repeated .NLPCommon.CorpusProto.Tagset.Category categories = 1;
inline int Tagset::categories_size() const {
  return categories_.size();
}
inline void Tagset::clear_categories() {
  categories_.Clear();
}
inline const ::NLPCommon::CorpusProto::Tagset_Category& Tagset::categories(int index) const {
  return categories_.Get(index);
}
inline ::NLPCommon::CorpusProto::Tagset_Category* Tagset::mutable_categories(int index) {
  return categories_.Mutable(index);
}
inline ::NLPCommon::CorpusProto::Tagset_Category* Tagset::add_categories() {
  return categories_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_Category >&
Tagset::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_Category >*
Tagset::mutable_categories() {
  return &categories_;
}

// repeated .NLPCommon.CorpusProto.Tagset.PartOfSpeech pos = 2;
inline int Tagset::pos_size() const {
  return pos_.size();
}
inline void Tagset::clear_pos() {
  pos_.Clear();
}
inline const ::NLPCommon::CorpusProto::Tagset_PartOfSpeech& Tagset::pos(int index) const {
  return pos_.Get(index);
}
inline ::NLPCommon::CorpusProto::Tagset_PartOfSpeech* Tagset::mutable_pos(int index) {
  return pos_.Mutable(index);
}
inline ::NLPCommon::CorpusProto::Tagset_PartOfSpeech* Tagset::add_pos() {
  return pos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_PartOfSpeech >&
Tagset::pos() const {
  return pos_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLPCommon::CorpusProto::Tagset_PartOfSpeech >*
Tagset::mutable_pos() {
  return &pos_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CorpusProto
}  // namespace NLPCommon

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NLPCommon::CorpusProto::Token_Type>() {
  return ::NLPCommon::CorpusProto::Token_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_corpus_2eproto__INCLUDED
